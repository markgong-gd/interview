### http传输大文件的方法

1. 数据压缩
客户端响应头：Accept-Encoding: gzip, deflate, br
服务端响应头：content-encoding: gzip

2. 分段请求
服务端响应头：transfer-encoding: chunked (长度未知，和content-length 互斥)

3. 范围请求
服务端响应头：accept-ranges: bytes
客户端请求头：range: bytes=x-y

场景：视频、音频就是采用一段一段范围传输，快进就是改变范围请求

4. 多段数据
客户端响应头：range: bytes=x-y, x-y
服务端响应头：
```http
    accept-ranges: bytes
    content-type: multipart/byteranges; boundary=00000000001
```

### http的连接管理

1. 短链接
缺点：需要频繁建立连接，每次建立连接三次握手，四次挥手开销极大。

2. 长连接
服务端响应头：connection: keep-alive

优点：解决上面短链接提到缺点

缺点：服务端不会主动关闭连接，占用资源，所以需要在恰当时间断开连接，比如设置打开时间、请求次数


***对头堵塞：*** 导致这个问题的原因--http基本的”请求-应答“模式，队列里的请求只会先进先出。

***解决：*** 并发连接。
缺点：如果并发量高后，服务器无法承受，会造成”拒绝服务“，在解决：多开几个服务器，来分担压力。

### 重定向和跳转

常用重定向状态码：301（永久），302（临时）.

重定向的过程：响应返回301/302状态码，客户端会查找响应头 Location 字段，自动拿到这个字段链接发起请求

重定向的问题：
    1. 性能损耗：一个重定向就多发送一次请求，滥用会增加服务器损耗；
    2. 循环跳转：重定向链路多后，有可能产生跳转循环

### http的cookie机制

1. 什么是cookie？

由于http是无状态的，为了让其有状态，cookie诞生了。cookie是存储在浏览器中的一组数据。

2. cookie工作过程

客户端请求头字段cookie，服务端响应头字段set-cookie传递.

3. cookie属性
- cookie有效期：expires：过期时间；max-age：存储最大时间，单位是秒；同时设置expires，优先级比expires高.
- cookie作用域：设置domain（域名）、path（路径）,发送请求是，会从URI中读取host、path对比。
- 字段httpOnly：告诉浏览器该cookie只能通过http协议传输，禁止其他方式读取。比如：document.cookie。**可以防患XSS**。
- 字段sameSite：**可以防患XSRF**。sameSite=Strict；严格禁止cookie随跳转链接跨站发送。sameSite=Lax;允许get/head等方法，禁止post跨站发送。
- secure：只能使用https加密传输，不能使用http明文传输，但是浏览器中cookie还是明文.
- 应用

1. 身份识别：存储用户登录态；
2. 广告跟踪：广告商给你贴上的一种cookie，在访问别的有关这个广告商页面时，可以识别你，然后给你推送相关广告，类似一种大数据行为。

### http的缓存

缓存：在计算机领域是一个优化利器，大量数据从缓存中读取，可以节省大量流量和时间。

1. 客户端（浏览器）缓存：
浏览器在发送请求时会先读取缓存，没有缓存，则发送请求，服务端返回带有*过期时间*的数据，浏览器存储起来。
服务器过期时间标记字段：cache-control: max-age=30，单位秒；和cookie的max-age不一样，**它开始计算时间是服务端数据响应开始**。

- cache-control其余字段：

        1. no-store: **不允许缓存**，用于某些变化非常频繁的数据，例如秒杀页面；
        2. no-cache：**可以缓存**，但是使用前必须去服务器验证是否过期，是否有最新的数据；没有就使用缓存，有就使用最新数据；
            协商缓存？
        3. must-revalidate：如果本地缓存没过期直接使用，过期则必须去服务端验证是否可以继续使用；

    - 点击浏览器刷新按钮行为：你会发现没有走缓存，因为浏览器会在请求报文中添加 ***cache-control: max-age=0;*** 字段，表示需要最新的数据
    - 浏览器ctrl + f5行为：浏览器会在请求报文中添加 ***cache-control: no-cache*** 字段
    - 前进、后退行为：你会发现请求成功状态码后面有 ***from disk cache*** 字样，意思是：没有发送网络请求，而是读取的磁盘上的缓存。实质是浏览器没有给请求报文添加 ***cache-control*** 字段.

- 条件请求：

        1. 使用场景：用来检查验证资源是否过期，服务器验证。
        2. 条件请求字段：if-modified-since、if-none-match。第一次请求是**响应报文**预先提供**last-modified、etag**值，缓存起来，第二次请求时**请求报文**带上缓存值，验证资源是否更新。没有更新返回**304 not modified**。
        3. last-modified: 文件最后修改时间; etag: 资源的一个唯一标识, 主要区别修改时间无法区别的情况。弱etag：在值前面有个***W/***标记，只要求资源语义无变化，但内部可能会有变化，例如html结构；强etag：要求在资源在字节级别必须相符。

### http的代理服务

1. 相关字段
- via: 标记代理身份, 只解决了是否存在代理问题，无法知道对方真实信息
- x-forwarded-ip、 x-forwarded-for、x-forwarded-host、x-forwarded-proto标记代理信息

### http的缓存代理

1. 相关字段
- private、public: private表示只能在客户端保存，默认为public。
- proxy-revalidate: 代理服务器的缓存过期后必须去验证。
- s-maxage: 限定缓存在代理服务器上存储时间。
- no-transform: 禁止修改缓存，比例缓存图片压缩。

### HTTPS是什么

1. https: 在http和tcp之间加入 ***SSL/TLS*** 层，是http层不直接应用在tcp上。
2. https与http区别：协议名、端口号443。

### 对称加密与非对称加密

1. 对称加密（有密钥就可以解密，密钥会在通讯过程中传递，会被窃取，无法解决密钥交换问题）
- 目前常用的对称加密算法：AES(对称加密算法)、ChaCha20；
- 对称算法**分组模式**：用固定长度的密钥加密任意长度的明文，即密钥转化为密文。常用：GCM、CCM、Poly1305.

2. 非对称加密（有两个密钥，公钥，私钥）(机密性)
公钥加密后只能用私钥解密，反过来私钥加密后只能用公钥解密。可以解决密钥交换问题。
- 常用非对称加密：RSA：加密后的密文长度现今 ***2048 bit***

- 混合加密：由于非对称加密算法复杂、位数大，使通信速度变慢很多。对称加密（AES）密钥a 加密会话，非对称加密（RSA）公钥加密密钥a ；私钥解密密钥a，密钥a 解密会话。（公钥加密、私钥解密）

### 数字签名与证书
没有密钥无法解读密文，但可以通过窃听收集到足够多的密文，在尝试模仿、修改发回网站。（此时需要完整性）

- 摘要算法：在传输时带上摘要随机数作对比。常用摘要算法：MD5、SHA-1、SHA-2

- 数字签名：私钥加密摘要串，公钥解密。（私钥加密，公钥解密）

公钥是公开的谁都可以发送，这样公钥容易被伪造。

公钥的信任：CA证书链，大CA证书 => 小CA证书 => rootCA（自己认证）。

### TLS1.2连接过程
TODO

### TLS1.3
TODO

### HTTPS的优化
TODO
